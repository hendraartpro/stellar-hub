
---
**Authors**: @slobo.eth and Avsa.eth

---
**Status**: draft

---

### Abstract

There are many reasons that we might want to be able to measure how and where users are registering names. One of them is simply by knowing our own ecosystem and which apps are more popular, but it’s also very important to be able to identify the creators who are helping the ecosystem. Retroactive funding via grants is often better than proactive funding because you can detect what has already worked, instead of stewards having to make bets on what they think would happen. Often in this community we are surprised by things becoming popular that we would never be able to predict. On the other hand, it’s important to make the process transparent, open source and privacy preserving. Having source data would also facilitate attempts to create referral programs.

### Specification

The ETH Registrar Controller takes as input: name, owner, duration, secret and resolver. The secret parameter is random data that obscures the name before the final step of the registration process is complete. It is 32 bytes of entropy and the ens manager app on app.ens.domains generates it by calling the following:

`require('crypto').randomBytes(32)`

This proposal suggests a social convention that generates the secret from a combination of taking the first **6 characters of a namehash**, add another **6 characters for extra data** and combines it with the appropriate number of random bytes.

This way the first 6 char of the secret would be the platform name and the next 6 would be reserved for internal data for that platform – like its own referral code. So for example if the above was registered via ensfairy the secret would be:

> 0x **1b7f8b** **612c63** 3cbcc635528d3b7196bc89d13566c1be2068af0cad6fb3ecebf0

With this we can attribute registrations using the first 12 chars of the secret. The loss of entropy of 48 bits is not relevant, since the only goal of the secret is to obscure the details of the bid to avoid front-running during the short period (usually a few minutes but it could be as long as a week) before the reveal transaction is executed. The secret still retains 208 bits which is highly secure, especially for a short time frame.

The extra data could be used in this example:

Alice refers bob to an ens registrar app using a custom link like app.ens.domains/?referral=AlicentIsAGoodFriend
If bob clicks that link, that information is saved on the cookies/ local storage (until it’s overwritten by another referral code, bob clears his memory or some time passes and the code expires). When bob wants to register a name, the secret will be prepended by the first 6 letters of the platform and then the next 6 characters generated by the sha256(‘AlicentIsAGoodFriend’). This allows that individuals who don't own a name registrar app but have their own audience to have a cross-registrar referral, which these registrars can choose to share revenue with.


## Privacy concerns

This action, by design, makes it public which apps the users are using to register names, and might reveal who they are friends or who they follow. It could review also some demographics of accounts–if a registrar app is known to be very popular in a country or to only have the UI in a language, it can reveal that a specific ethereum address might be from that demographic. This is not unlike seeing a user send funds to a known exchange address.

To alleviate these concerns, we ask app makers to make the process transparent and allow users to opt-out of either the referral code or the whole platform code being added on their secret.

This would also enable to compare different clients usage–again this is by design. If a given platform doesn’t want any of their numbers public, they can simply not implement it.

## A reverse code registry

Since the source code is derived from the namehash, it's not reversible. Therefore, some sort of registry of names is needed to make sense of these names. Such registrars could be made on chain or simply be a git text file with multiple forks over many repos. A registrar definition is outside the scope of this ENSIP because if the ground truth was on-chain it would be relatively easy to game. 

With purely a random number, it would take about 1800 registrants to create a 10% chance of an accidental collision, and by 4800 registrants that chance increases to 50%. Since each code is expected to be used by registrar apps and websites, and not users (that's what the extra data is for), we expect that number to be below a thousand and such collisions to be rare. But of course, it's trivial to generate such collisions or spam the registry, and therefore instead of trying to play that securityy cat and mouse, we would rather leave the "truth" of the codes to its usage. If someone is using them to create a ranking website, or launch a referral program, each should simply exercise common sense to maintain their own copy of that registry for the top of the ranking.

### Other questions

Isn’t it possible to add other platform codes in yours? Yes. We don’t see that as a concern, since platforms probably want to maximize their own numbers

Is this coming with a referral program? No. This is simply about adding the data so we could have a leaderboard. What to do with the data is for another time.

Does this replace the proposed v2 registrar 3? No. That contract–if implemented–would be a code change that would allow a trustless referral program, immediate and on-chain. This change would not require any code change and would simply provide the data, requiring steward working groups to then act on it on a later date.

Can this be done with Google Analytics? Any registrar app can use their own analytics software to analyze their own usage, but this would allow to create a trustless way in which multiple clients could prove their own name usage.
Updates
